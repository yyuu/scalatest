package org.scalatest

import java.util.Date

/**
 * A base class for the events that can be passed to the report function passed
 * to the <code>execute</code> method of a <code>Suite</code>.
 */
sealed abstract class Event(
  val runStamp: long,
  val suiteStamp: List[Int],
  val timeStamp: long
) extends Ordered[Event] {

  if (suiteStamp == null)
    throw new NullPointerException("suiteStamp was null")

  /**
   * Result of comparing <code>this</code> event with event passed as <code>that</code>. Returns
   * x where x < 0 iff this < that, x == 0 iff this == that, x > 0 iff this > that.
   *
   * @param that the event to compare to this event
   * @param return an integer indicating whether this event is less than, equal to, or greater than
   * the passed event
   */
  def compare(that: Event): Int = 0
}
/**
 * Event that indicates a suite (or other entity) is about to start running a test.
 *
 * <p>
 * For example, trait <code>Suite</code> uses <code>TestStarting</code> to report
 * that a test method of a <code>Suite</code> is about to be invoked.
 * </p>
 *
 * <p>
 * This class has a private constructor. To create instances of this class you must
 * use one of the factory methods provided in its <a href="TestStarting$object.html">companion object</a>. For example, given a
 * report function named <code>report</code>, you could fire a <code>TestStarting</code> event like this:
 * </p>
 *
 * <pre>
 * report(TestStarting(userFriendlyName, suiteName, thisSuite.getClass.getName, testName))
 * </pre>
 *
 * @param name a localized name identifying the test that is starting, which should include the
 *     suite and test names, suitable for presenting to the user
 * @param suiteName the name of the suite containing the test that is starting
 * @param suiteClassName an optional fully qualifed <code>Suite</code> class name containing the test that is starting
 * @param testName the name of the test that is starting
 * @param fromSpec indicates the event was generated by a specification-style suite, which if true will likely
 *                 mean the event will be supressed (<em>i.e.</em>, not shown) in specification-like output presented to the user
 * @param rerunnable an optional <code>Rerunnable</code> that can be used to rerun the test that is starting (if <code>None</code>
 *                   is passed, the test cannot be rerun)
 * @param payload an optional object that can be used to pass custom information to the reporter about the test starting event
 * @param threadName a name for the <code>Thread</code> about whose activity this event was reported
 * @param timeStamp a <code>Date</code> indicating the time this event was reported
 *
 * @throws NullPointerException if any of the passed values are <code>null</code>
 */
final class TestStarting private (
  val name: String,
  val suiteName: String,
  val suiteClassName: Option[String],
  val testName: String,
  runStamp: long,
  suiteStamp: List[Int],
  val fromSpec: Boolean,
  val rerunnable: Option[Rerunnable],
  val payload: Option[Any],
  val threadName: String,
  timeStamp: long
) extends Event(runStamp, suiteStamp, timeStamp) {
    
  if (name == null)
    throw new NullPointerException("name was null")
  if (suiteName == null)
    throw new NullPointerException("suiteName was null")
  if (suiteClassName == null)
    throw new NullPointerException("suiteClassName was null")
  if (testName == null)
    throw new NullPointerException("testName was null")
  if (rerunnable == null)
    throw new NullPointerException("rerunnable was null")
  if (payload == null)
    throw new NullPointerException("payload was null")
  if (threadName == null)
    throw new NullPointerException("threadName was null")

  /**
   * Indicates whether some other object is structurally "equal to" this one.
   *
   * @param other the object to compare to this object for equality
   * @return true if this object is the same as the obj argument; <code>false</code> otherwise
   */
  override def equals(other: Any): Boolean = {
    other match {
      case that: TestStarting =>
        name == that.name &&
        suiteName == that.suiteName &&
        suiteClassName == that.suiteClassName &&
        testName == that.testName &&
        runStamp == that.runStamp &&
        suiteStamp == that.suiteStamp &&
        fromSpec == that.fromSpec &&
        rerunnable == that.rerunnable &&
        payload == that.payload &&
        threadName == that.threadName &&
        timeStamp == that.timeStamp
      case _ => false
    }
  }

  /**
   * Returns a hash code value for this object.
   *
   * @return a hash code value for this object
   */
  override def hashCode: Int =
    41 * (
      41 * (
        41 * (
          41 * (
            41 * (
              41 * (
                41 * (
                  41 * (
                    41 * (
                      41 * (
                        41 + name.hashCode
                      ) + suiteName.hashCode
                    ) + suiteClassName.hashCode
                  ) + testName.hashCode
                ) + runStamp.hashCode
              ) + suiteStamp.hashCode
            ) + fromSpec.hashCode
          ) + rerunnable.hashCode
        ) + payload.hashCode
      ) + threadName.hashCode
    ) + timeStamp.hashCode
}

/**
 * Companion object for the <a href="TestStarting.html"><code>TestStarting</code></a> event, which contains overloaded factory methods
 * and an extractor method to facilitate pattern matching on <code>TestStarting</code> objects.
 */
object TestStarting {

  /**
   * Constructs a new <code>TestStarting</code> event with the passed parameters.
   *
   * @param name a localized name identifying the test that is starting, which should include the
   *     suite and test names, suitable for presenting to the user
   * @param suiteName the name of the suite containing the test that is starting
   * @param suiteClassName an optional fully qualifed <code>Suite</code> class name containing the test that is starting
   * @param testName the name of the test that is starting
   * @param fromSpec indicates the event was generated by a specification-style suite, which if true will likely
   *                 mean the event will be supressed (<em>i.e.</em>, not shown) in specification-like output presented to the user
   * @param rerunnable an optional <code>Rerunnable</code> that can be used to rerun the test that is starting (if <code>None</code>
   *                   is passed, the test cannot be rerun)
   * @param payload an optional object that can be used to pass custom information to the reporter about the test starting event
   * @param threadName a name for the <code>Thread</code> about whose activity this event was reported
   * @param timeStamp a <code>Date</code> indicating the time this event was reported
   *
   * @throws NullPointerException if any of the passed values are <code>null</code>
   */
  def apply(
      name: String,
      suiteName: String,
      suiteClassName: Option[String],
      testName: String,
      runStamp: long,
      suiteStamp: List[Int],
      fromSpec: Boolean,
      rerunnable: Option[Rerunnable],
      payload: Option[Any],
      threadName: String,
      timeStamp: long
  ): TestStarting = {
    new TestStarting(name, suiteName, suiteClassName, testName, runStamp, suiteStamp, fromSpec, rerunnable, payload, threadName, timeStamp)
  }

  /**
   * Constructs a new <code>TestStarting</code> event with the passed parameters, passing the current threads
   * name as <code>threadname</code> and the current time as <code>timeStamp</code>.
   *
   * @param name a localized name identifying the test that is starting, which should include the
   *     suite and test names, suitable for presenting to the user
   * @param suiteName the name of the suite containing the test that is starting
   * @param suiteClassName an optional fully qualifed <code>Suite</code> class name containing the test that is starting
   * @param testName the name of the test that is starting
   * @param fromSpec indicates the event was generated by a specification-style suite, which if true will likely
   *                 mean the event will be supressed (<em>i.e.</em>, not shown) in specification-like output presented to the user
   * @param rerunnable an optional <code>Rerunnable</code> that can be used to rerun the test that is starting (if <code>None</code>
   *                   is passed, the test cannot be rerun)
   * @param payload an optional object that can be used to pass custom information to the reporter about the test starting event
   *
   * @throws NullPointerException if any of the passed values are <code>null</code>
   * @return a new <code>TestStarting</code> instance initialized with the passed and default values
   */
  def apply(
    name: String,
    suiteName: String,
    suiteClassName: Option[String],
    testName: String,
    runStamp: long,
    suiteStamp: List[Int],
    fromSpec: Boolean,
    rerunnable: Option[Rerunnable],
    payload: Option[Any]
  ): TestStarting = {
    apply(name, suiteName, suiteClassName, testName, runStamp, suiteStamp, fromSpec, rerunnable, payload, Thread.currentThread.getName, (new Date).getTime)
  }

  /**
   * Constructs a new <code>TestStarting</code> event with the passed parameters, passing <code>None</code> as the
   * <code>payload</code>, the current threads name as <code>threadname</code>, and the current time as <code>timeStamp</code>.
   *
   * @param name a localized name identifying the test that is starting, which should include the
   *     suite and test names, suitable for presenting to the user
   * @param suiteName the name of the suite containing the test that is starting
   * @param suiteClassName an optional fully qualifed <code>Suite</code> class name containing the test that is starting
   * @param testName the name of the test that is starting
   * @param fromSpec indicates the event was generated by a specification-style suite, which if true will likely
   *                 mean the event will be supressed (<em>i.e.</em>, not shown) in specification-like output presented to the user
   * @param rerunnable an optional <code>Rerunnable</code> that can be used to rerun the test that is starting (if <code>None</code>
   *                   is passed, the test cannot be rerun)
   *
   * @throws NullPointerException if any of the passed values are <code>null</code>
   * @return a new <code>TestStarting</code> instance initialized with the passed and default values
   */
  def apply(
    name: String,
    suiteName: String,
    suiteClassName: Option[String],
    testName: String,
    runStamp: long,
    suiteStamp: List[Int],
    fromSpec: Boolean,
    rerunnable: Option[Rerunnable]
  ): TestStarting = {
    apply(name, suiteName, suiteClassName, testName, runStamp, suiteStamp, fromSpec, rerunnable, None, Thread.currentThread.getName, (new Date).getTime)
  }

  /**
   * Constructs a new <code>TestStarting</code> event with the passed parameters, passing <code>None</code> as the
   * <code>rerunnable</code>, <code>None</code> as the <code>payload</code>, the current threads name as <code>threadname</code>,
   * and the current time as <code>timeStamp</code>.
   *
   * @param name a localized name identifying the test that is starting, which should include the
   *     suite and test names, suitable for presenting to the user
   * @param suiteName the name of the suite containing the test that is starting
   * @param suiteClassName an optional fully qualifed <code>Suite</code> class name containing the test that is starting
   * @param testName the name of the test that is starting
   * @param fromSpec indicates the event was generated by a specification-style suite, which if true will likely
   *                 mean the event will be supressed (<em>i.e.</em>, not shown) in specification-like output presented to the user
   *
   * @throws NullPointerException if any of the passed values are <code>null</code>
   * @return a new <code>TestStarting</code> instance initialized with the passed and default values
   */
  def apply(
    name: String,
    suiteName: String,
    suiteClassName: Option[String],
    testName: String,
    runStamp: long,
    suiteStamp: List[Int],
    fromSpec: Boolean
  ): TestStarting = {
    apply(name, suiteName, suiteClassName, testName, runStamp, suiteStamp, fromSpec, None, None, Thread.currentThread.getName, (new Date).getTime)
  }

  /**
   * Constructs a new <code>TestStarting</code> event with the passed parameters, passing <code>false</code> for
   * <code>fromSpec</code>, <code>None</code> as the <code>rerunnable</code>, <code>None</code> as the <code>payload</code>,
   * the current threads name as <code>threadname</code>, and the current time as <code>timeStamp</code>.
   *
   * @param name a localized name identifying the test that is starting, which should include the
   *     suite and test names, suitable for presenting to the user
   * @param suiteName the name of the suite containing the test that is starting
   * @param suiteClassName an optional fully qualifed <code>Suite</code> class name containing the test that is starting
   * @param testName the name of the test that is starting
   *
   * @throws NullPointerException if any of the passed values are <code>null</code>
   * @return a new <code>TestStarting</code> instance initialized with the passed and default values
   */
  def apply(
    name: String,
    suiteName: String,
    suiteClassName: Option[String],
    testName: String,
    runStamp: long,
    suiteStamp: List[Int]
  ): TestStarting = {
    apply(name, suiteName, suiteClassName, testName, runStamp, suiteStamp, false, None, None, Thread.currentThread.getName, (new Date).getTime)
  }

  /**
   * An extraction method that facilitates pattern matching on <code>TestStarting</code> events.
   *
   * @param event the <code>TestStarting</code> event from which to extract
   *
   * @throws NullPointerException if the passed <code>event<code> is <code>null</code>
   * @return an optional tuple of the values provided to the passed <code>TestStarting</code> event's primary constructor
   */
  def unapply(event: TestStarting): Option[(String, String, Option[String], String, Long, List[Int], Boolean, Option[Rerunnable], Option[Any], String, long)] =
    Some(event.name, event.suiteName, event.suiteClassName, event.testName, event.runStamp, event.suiteStamp, event.fromSpec, event.rerunnable, event.payload, event.threadName, event.timeStamp)
}
